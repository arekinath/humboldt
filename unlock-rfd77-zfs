#!/bin/bash
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

#
# Copyright (c) 2017, Joyent, Inc.
#

set -o pipefail

. /lib/svc/share/smf_include.sh

smf_is_globalzone || exit $SMF_EXIT_OK

fatal() {
	echo "fatal:" "$@" >&2
	exit $SMF_EXIT_ERR_FATAL
}

stop() {
	echo "skipping unlock:" "$@" >&2
	exit $SMF_EXIT_OK
}

#
# If we booted in noimport mode, then don't do any unlocking.
#
/bin/bootparams | grep "^noimport=true" >/dev/null
if [[ $? -eq 0 ]]; then
	stop "system booted noimport mode"
fi

#
# We need the links to /dev/dsk. Rather than trying to play games with manually
# invoking syseventd ask devfsadm to do some work.
#
/usr/sbin/devfsadm -c disk

#
# Make sure the pool is imported
#
zpool import -f zones

#
# Check that we're on a PI that has zfs encryption at all before going any
# further.
#
read encstatus < <(zpool get -o value -pH feature@encryption zones)
if [[ "z${encstatus}" == "z" ]]; then
	stop "ZFS encryption not enabled on this system"
fi

#
# Get the PIN code for the PIV applet we need to use out of our boot args
#
read pivpin < <(bootparams | awk -F= '$1 == "piv-pin" { print $2; exit(0); }')

#
# If we're in a qemu VM with the emulated CCID device, after reboot it's often
# out of sync with us. Doing a list command will cause PCSC to reset it and
# bring it back into sync.
#
pivtool list >/dev/null 2>/dev/null

try_unlock() {
	local fs="$1"
	local box="$2"
	local opts="$3"
	if [[ "z${opts}" == "z" && "z${pivpin}" != "z" ]]; then
		opts="-P ${pivpin}"
	fi
	echo "$box" | \
	    openssl enc -base64 -d | \
	    pivtool ${opts} unbox >/dev/null 2>/tmp/pivtool.err.out.$$
	local pivret="$?"
	if [[ $pivret -eq 0 ]]; then
		echo "$box" | \
		    openssl enc -base64 -d | \
		    pivtool ${opts} unbox | \
		    zfs load-key "${fs}"
		local loadret="$?"
		if [[ $loadret -eq 0 ]]; then
			zfs mount "$fs"
		fi
		return $loadret
	elif [[ $pivret -eq 4 ]]; then
		mkfifo /tmp/pivpin.pipe.$$
		/smartdc/lib/sdc-on-tty -d /dev/console \
		    /smartdc/lib/piv-prompt-pin.sh "/tmp/pivpin.pipe.$$" \
		    "$(cat /tmp/pivtool.err.out.$$)" &
		read pin < /tmp/pivpin.pipe.$$
		rm -f /tmp/pivpin.pipe.$$ /tmp/pivtool.err.out.$$
		try_unlock "$fs" "$box" "-P ${pin}"
		return $?
	fi
}

#
# Now run around any encrypted datasets on the system and unlock them.
#
zfs list -p -H -o name,encryptionroot,rfd77:local-box | \
    while read name encroot box; do
	if [[ "${name}" == "${encroot}" && "${name}" != "zones/swap" && "${box}" != "-" ]]; then
		if ! try_unlock "$name" "$box"; then
			fatal "failed to unlock $name"
		fi
	fi
done

#
# Re-create the swap zvol at each boot with a unique key for that boot.
# This way it's unreadable after a reboot.
#
read sz < <(zfs get -pH -o value volsize zones/swap)
if [[ $? -eq 0 && $sz -gt 0 ]]; then
	zfs destroy zones/swap || fatal "zfs destroy swap failed"
	dd if=/dev/random bs=32 count=1 | \
	    zfs create -V $sz -o encryption=on -o keyformat=raw zones/swap \
	    || fatal "creating swap zvol failed"
fi

exit $SMF_EXIT_OK
